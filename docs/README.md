# rust-aec Documentation (English)

## 1. Introduction

### 1.1 Purpose

- Describe how to use the `rust-aec` crate, its public interfaces, and important notes.
- Provide guidance for decoding CCSDS 121.0-B-3 AEC bitstreams, especially GRIB2 Data Representation Template 5.0 = 42.
- Provide a quick reference for streaming (incremental) decoding and the one-shot API for integration and maintenance.

### 1.2 Intended audience

- Rust developers integrating AEC decoding into data processing pipelines.
- Meteorological/GRIB2 developers who need to decode GRIB2 Section 7 AEC payloads.
- Users who want to avoid native build dependencies (C/CMake/libclang), particularly on Windows.

## 2. Purpose and Use Cases

### 2.1 Feature overview

`rust-aec` is a pure Rust implementation of CCSDS 121.0-B-3 AEC focused on GRIB2 template 5.0=42.
The crate provides:

- One-shot decoding APIs for simple integration.
- A streaming decoder API (`Decoder`) that supports chunked input and chunked output.
- Utilities for mapping GRIB2 `ccsdsFlags` to the crate's `AecFlags`.

### 2.2 Feature list

- `decode()` / `decode_into()` one-shot decoding.
- `Decoder` streaming decoder with `push_input` and `decode` methods.
- `flags_from_grib2_ccsds_flags()` helper.
- Oracle tests for byte-for-byte verification when sample payloads are available.

## 3. Runtime Requirements

### 3.1 Software environment

- Rust toolchain (MSRV: 1.85 specified in `Cargo.toml`).
- Build and test with standard `cargo` commands (`cargo test`, `cargo run`).

### 3.2 External dependencies

- Pure Rust; no external native libraries required.
- Crate dependencies: `bitflags` (runtime), `anyhow` (dev-dependency for examples/tests).

### 3.3 Configuration files

- No configuration files are required by the crate.
- Optional test artifacts (for local verification):
  - `aec_payload.bin`: AEC payload (e.g., GRIB2 Section 7 data).
  - `aec_decoded_oracle.bin`: Oracle output generated by `libaec` for byte-for-byte comparison.

> Tests that depend on these files skip automatically if the files are absent.

## 4. API Reference

(See code-level docs / doc comments for full signatures.)

### 4.1 One-shot API

- `decode(input: &[u8], params: AecParams, output_samples: usize) -> Result<Vec<u8>, AecError>`
- `decode_into(input: &[u8], params: AecParams, output_samples: usize, output: &mut [u8]) -> Result<(), AecError>`

Notes:
- `bytes_per_sample = ceil(bits_per_sample / 8)` (subject to flags like `DATA_3BYTE`).
- When `AecFlags::DATA_PREPROCESS` is set, output bytes are reconstructed sample values.

### 4.2 Streaming API

- `Decoder::new(params, output_samples)`
- `Decoder::push_input(&mut self, input: &[u8])`
- `Decoder::decode(&mut self, out: &mut [u8], flush: Flush) -> Result<(usize, DecodeStatus), AecError>`

Status values:
- `DecodeStatus::NeedInput` — more input required.
- `DecodeStatus::NeedOutput` — output buffer filled; provide more space.
- `DecodeStatus::Finished` — produced all requested output.

Flush variants:
- `Flush::NoFlush` — expect more input later.
- `Flush::Flush` — no more input will be provided; incomplete streams will error.

### 4.3 GRIB2 mapping helper

- `flags_from_grib2_ccsds_flags(ccsds_flags: u8) -> AecFlags`
- Caller must still supply `bits_per_sample`, `block_size`, `rsi`, and `output_samples` from GRIB2 metadata.

## 5. Architecture

### 5.1 Overall architecture

- `lib.rs` exports the public API and helpers.
- `decoder.rs` implements both the one-shot decoder and the streaming `Decoder`.
- `bitreader.rs` is a MSB-first bit reader used by the decoder.
- `params.rs` and `error.rs` define runtime parameters and errors.

### 5.5 Key design choices

- Pure Rust implementation to avoid native build friction.
- Clear separation between one-shot and streaming APIs.
- Streaming API modeled with `NeedInput/NeedOutput/Finished` semantics and explicit flushing.
- Optional oracle testing approach that is local-only and skipped in CI when files are absent.

## 6. Usage

### 6.1 Quick one-shot example

```rust
use rust_aec::{decode, flags_from_grib2_ccsds_flags, AecParams};

let params = AecParams::new(12, 32, 128, flags_from_grib2_ccsds_flags(0x0e));
let decoded = decode(&payload, params, num_points)?;
```

### 6.2 Streaming example (driver loop)

- Feed `push_input()` with input chunks.
- Repeatedly call `decode()` until `NeedInput` or `Finished`.
- When no more input will arrive, call `decode(..., Flush::Flush)` to finalize.

A full streaming example is provided in `examples/stream_decode_aec_payload.rs`.

## Screenshots (placeholders)

- (placeholder) streaming example output
- (placeholder) oracle test output
- (placeholder) visual comparison with libaec
